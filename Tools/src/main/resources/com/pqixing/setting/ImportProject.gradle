//1.0
/**
 *
 * Created by pqixing on 18-2-3.
 * this class will run on setting.gradle,so can not import any other class
 */
public class ImportProject {

    final String includeKt = "import.kt"
    final String defaultXmlPath = "manager/project.xml"
    final String dpsPath = "manager/dependency"

    File rootDir

    /**
     * 解析xml后，存放入待解析的工程路径
     */
    HashMap<String, String> projectPaths = new HashMap<>()

    HashSet<String> includes = new HashSet<>()
    HashSet<String> focusIncludes = new HashSet<>()
    HashSet<String> excludes = new HashSet<>()
    HashSet<String> dpsExcludes = new HashSet<>()
    HashSet<String> dpsIncludes = new HashSet<>()
    String codeRoot
    File codeRootDir
    Gradle gradle

    ImportProject(Gradle gradle, File rootDir) {
        this.rootDir = rootDir
        this.gradle = gradle
    }

    void readFromEnv() {
        System.getProperties().each { it ->
            if (it.key.toString().startsWith("val")) {
                parseValue(it.key.toString(), it.value.toString())
            }
        }
    }
    /**
     * 解析本地需要导入的工程
     */
    void formatInclude(File includeFile) {
        if (includeFile == null || !includeFile.exists() || !includeFile.isFile()) return
        for (String line in includeFile.readLines()) {
            if (line.trim().startsWith("//END")) return
            def map = line.replaceAll("//.*", "").split("=")
            if (map.length < 2) continue
            parseValue(map[0], map[1])
        }
    }

    private void parseValue(String k, String v) {
        String key = k.replace("var ", "").replace("val ", "").replace("\"", "").trim()
        String value = v.replace("+", ",").trim()
        switch (key) {
            case "targetInclude": formatInclude(new File(value))
                break
            case "include":
                value?.split(",")?.each { includes.add(it.trim()) }
                break
            case "focusInclude":
                value?.split(",")?.each { focusIncludes.add(it.trim()) }
                break
            case "dpsInclude"://批量导入子项目
                value?.split(",")?.each { dpsIncludes.add(it.trim()) }
                break
            case "dpsExclude"://批量忽略子项目
                value?.split(",")?.each { dpsExcludes.add(it.trim()) }
                break
            case "exclude":
                value?.split(",")?.each { excludes.add(it.trim()) }
                break
            case "codeRoot":
                if (!value.isEmpty())
                    codeRoot = value
                break
            default: return
        }
    }


    void readDps(String type, String dpsName) {
        String url = projectPaths.find { it.key == dpsName }?.value
        if (url == null || url.isEmpty()) return

        def f = new File(rootDir, "$dpsPath/$dpsName")
        if (!f.exists()) {
            println("$dpsName  version file :$f.absolutePath  not found , please run task DpsAnaly")
            return
        }
        String[] map = f.text.trim().replaceAll("//.*", "").split("=")
        parseValue(type, map[map.length - 1])
    }

    /**
     * 解析default xml 加载所有的git信息
     */
    void formatXml() {
        File defaultXml = new File(rootDir, defaultXmlPath)
        if (!defaultXml.exists()) return
        Node gitNode = new XmlParser().parse(defaultXml)
        gitNode.project.each { Node p ->
            String name = p.@name
            def childens = p.submodule
            if (childens.size() > 0) childens.each { Node s ->
                String s_name = s.@name
                projectPaths.put(s_name, "$name/$s_name")
            } else projectPaths.put(name, name)
        }
    }

    String makeIncludeTxt() {
        HashSet<String> resultInclude = new HashSet()
        focusIncludes.each { key ->
            String k = key.replace('"', "").trim()
            if (!k.isEmpty()) {
                resultInclude.add(k)
            }
        }
        if (resultInclude.isEmpty()) {
            includes.each { key ->
                if (!key.isEmpty()) resultInclude.add(key)
            }
            excludes.each { key ->
                if (!key.isEmpty()) resultInclude.remove(key)
            }
        }
//        println("resultInclude -> $resultInclude focusIncludes->$focusIncludes projectPaths -> $projectPaths")
        StringBuilder sb = new StringBuilder("// $codeRootDir.absolutePath \n")
        def dir = codeRootDir.absolutePath
        resultInclude.each { key ->
            def value = projectPaths[key]
            if (value != null) {
                sb.append("\ninclude (':$key') \n    project(':$key').projectDir = new File('$dir','${value.replace("\\", "/")}')")
            }
        }

        return sb.toString()
    }

    public void formatDps() {
        dpsIncludes.each { readDps("include", it) }
        dpsExcludes.each { readDps("exclude", it) }
    }

    String save() {
        formatXml()
        formatInclude(new File(rootDir, includeKt))
        readFromEnv()
        formatCodeRoot()
        formatDps()
        return makeIncludeTxt()
    }

    private void formatCodeRoot() {
        if (codeRoot.isEmpty()) {
            codeRoot = "../"
        }
        codeRoot = codeRoot.replace('"', "")
        codeRootDir = codeRoot.startsWith("../") ? getDir(rootDir, codeRoot) : new File(codeRoot)
        gradle.ext.codeRootDir = codeRootDir
    }

    private File getDir(File dir, String codeRoot) {
        codeRoot.split("/").each {
            if (it == "..") dir = dir.parentFile
            else dir = new File(dir, it)
        }
        return dir
    }

}

File rootDir = settings.rootDir
File outDir = new File(rootDir, "build/modularization")
if (!outDir.exists()) outDir.mkdirs()
try {
    String text = new ImportProject(gradle, rootDir).save()
    File outFile = new File(outDir, "import.gradle")
    outFile.parentFile.mkdirs()
    outFile.write(text)
    apply from: outFile.absolutePath
} catch (Exception e) {//if fail delete self
    new File(outDir, "ImportProject.gradle").delete()
    throw new RuntimeException(e)
}